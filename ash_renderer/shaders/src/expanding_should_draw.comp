#version 460

#extension GL_ARB_separate_shader_objects: enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require
#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_KHR_shader_subgroup_vote: enable

#include "structs\cluster_data.glsl"
#include "structs\indirect_draw_data.glsl"
#include "structs\mesh_task_payload.glsl"
#include "structs\camera.glsl"
#include "structs\model.glsl"



//@group(0) @binding(0) var<storage, write> result_indicies: array<i32>;


// layout(binding = 0) writeonly buffer ResultIndicies {
//     uint result[];
// } result_indicies;

// layout(binding = 1) writeonly buffer DrawIndirectParams {
//     DrawIndexedIndirect result[];
// } draw_indirect_params; 



layout (binding = 0) readonly buffer ModelUniformBufferObject {
    Model models[];
};

layout(binding = 2) readonly buffer Clusters {
    ClusterData clusters[];
};

layout(binding = 1) writeonly buffer ShouldDraw {
    uint should_draw[];
};

layout (binding = 3) readonly uniform CameraUniformBufferObject {
    CameraUniformObject ubo; 
};

layout (std430, binding = 6) buffer IndirectDrawBuffer {
    IndirectDrawData indirect_draw[]; 
} ;

const float LARGE_ERROR = 100000000000000000.0;

float cluster_error(uint idx, uint idy) {
    bool out_of_range = false;
    if (out_of_range) {
        return LARGE_ERROR;
    } else {
		vec3 cam = (models[idy].inv_model * vec4(ubo.camera_pos, 1.0)).xyz ;
		vec3 center = clusters[idx].center;
		float radius = clusters[idx].radius;
		float error = clusters[idx].error;

		vec3 vec = center - cam;
		float inv_center_distance = 1/(dot(vec, vec));
        return error * error * radius * radius * inv_center_distance;
		
    }
}

const uint LOCAL_SIZE_X = 32;

const uint STARTING = 32;

layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

const uint QUEUE_SIZE = 10000;

shared uint[QUEUE_SIZE] queue;

 
void main() {
	uint idx = gl_GlobalInvocationID.x;
    uint instance = gl_GlobalInvocationID.y;

	for (int i = 0; i < STARTING; i++){
		queue[i] = i;
	}

	uint queue_tail = STARTING;

	uint old_queue_size = 0;
	uint queue_head = 0;

    //uint len = indices.result.length();

    // if (i == 0) {
    //     should_draw.result[offset + 0] = len;
    // }

    // if (i >= len) {
    //     return;
    // }
    // should_draw[i] = i32(clusters[i].index_offset);

    //uint start = clusters[i].index_offset;
    //uint end = start + clusters[i].index_count;

	// Calculate if this cluster should be drawn:
	// draw_error >= min(self.error, self.co-parent.error) 
	// draw_error < min(parent0.error, parent1.error)

	uint pos = 0;

	uint its = 3;

	//for (uint i = id.x; i < clusters.length(); i += LOCAL_SIZE_X){
		// lots of negative zeros

	// only evaluate if we are within the bounds of the queue

	while (queue_tail - queue_head > 0 && its > 0){
		its--;

		old_queue_size = queue_tail - queue_head;

		memoryBarrierShared();

		if (idx < old_queue_size){

			queue_head += idx;

			uint i = queue[queue_head % QUEUE_SIZE];


			float this_error = -LARGE_ERROR;

			if (clusters[i].co_parent >= 0) {
				this_error = min(cluster_error(i, instance), cluster_error(clusters[i].co_parent, instance));
			}

			// lots of zeros
			float parent_error = LARGE_ERROR;

			if (clusters[i].parent0 >= 0) { // If we have one parent, we are guarenteed to have another.
				parent_error = min(cluster_error(clusters[i].parent0, instance), cluster_error(clusters[i].parent1, instance));
			}
			float error = ubo.target_error * ubo.target_error;

			bool draw = error >= this_error && error < parent_error;


			bool can_queue_children = clusters[i].min_child_index >= 0 && queue_tail  < QUEUE_SIZE;

			if (draw  ){

				pos += idx + 1;
				should_draw[pos-1] = i + 1;

			}else{
				// add children to queue

				if (i < clusters[i].co_parent && can_queue_children){
					uint children = min(clusters[i].max_child_index - clusters[i].min_child_index, 8);

					queue_tail += subgroupExclusiveAdd(children);
					// add to queue
					for (uint c = 0; c < children; c++){
						uint index = c + clamp(clusters[i].min_child_index, 0, 8);
						if (index >= STARTING){
							queue[(queue_tail + c) % QUEUE_SIZE] = index;
						}
					}
					queue_tail += children;
						
					//queue[(queue_tail) % QUEUE_SIZE] = clusters[i].min_child_index;
					

				}

			}
		}

		pos = subgroupMax(pos) ;
		// Increment by the amount of work done.
		//queue_head += 1;// ;

		queue_head = subgroupMax(queue_head);
		queue_tail = subgroupMax(queue_tail);
	}

	if (subgroupElect()) {

		for (int i = 0; i < TASK_GROUP_SIZE; i++){
			should_draw[pos + i + 1] = 0;
		}

		indirect_draw[instance].group_size_x = ((pos + 3) / TASK_GROUP_SIZE);
	}
}