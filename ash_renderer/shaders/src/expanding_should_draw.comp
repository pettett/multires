#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_EXT_control_flow_attributes : require
// #extension GL_EXT_debug_printf : enable

#include "structs\camera.glsl"
#include "structs\cluster_data.glsl"
#include "structs\indirect_draw_data.glsl"
#include "structs\mesh_task_payload.glsl"
#include "structs\model.glsl"
#include "structs\range.glsl"

//@group(0) @binding(0) var<storage, write> result_indicies: array<i32>;

// layout(binding = 0) writeonly buffer ResultIndicies {
//     uint result[];
// } result_indicies;

// layout(binding = 1) writeonly buffer DrawIndirectParams {
//     DrawIndexedIndirect result[];
// } draw_indirect_params;

layout(binding = 0) readonly buffer ModelUniformBufferObject {
	Model models[];
};

layout(binding = 2) readonly buffer Clusters {
	ClusterData clusters[];
};

layout(binding = 1) writeonly buffer ShouldDraw {
	uint should_draw[];
};

layout(binding = 3) readonly uniform CameraUniformBufferObject {
	CameraUniformObject ubo;
};

layout(std430, binding = 6) buffer IndirectDrawBuffer {
	IndirectDrawData indirect_draw[];
};

layout(std430, binding = 7) buffer RangeBuffer {
	Range ranges[];
};

const float LARGE_ERROR = 100000000000000000.0;

// Use minimim of co_parent errors. Causes weirdness otherwise for some reason
#define MIN_ERROR

#include "util\cluster.glsl"

bool can_draw(uint idx, uint idy, out bool high_error) {
	vec3 local_cam_pos = (models[idy].inv_model * vec4(ubo.camera_pos, 1.0)).xyz;

	float this_error = get_this_error(idx, local_cam_pos);
	float parent_error = get_parent_error(idx, local_cam_pos);

	float error = ubo.target_error * ubo.target_error;

	high_error = this_error > error;
	bool draw = error >= this_error && error < parent_error;

	return draw;
}

const uint LOCAL_SIZE_X = 32;

layout(local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

const uint QUEUE_SIZE = 3000;
const uint STARTING = 8;

shared uint[QUEUE_SIZE] queue;

void main() {
	uint idx = gl_GlobalInvocationID.x;
	uint instance = gl_WorkGroupID.y;

	[[unroll]] for (int i = 0; i < STARTING; i++) { queue[i] = i; }

	uint queue_tail = STARTING;
	uint queue_head = 0;

	// leave some room for the number of clusters produced by the previous to increase
	uint start = instance == 0 ? 0 : ranges[instance - 1].end + 100;

	// offset by the maximum cluster count in a mesh
	// uint start = instance * clusters.length() / 2;

	if (subgroupElect()) {
		ranges[instance].start = start;
	}
	uint pos = start;

	// if (subgroupElect()) {
	// 	debugPrintfEXT("Starting %d \n", instance);
	// }

	// only evaluate if we are within the bounds of the queue
	while (queue_tail - queue_head > 0) {
		// old_queue_size = queue_tail - queue_head;

		subgroupMemoryBarrierShared();

		if (idx < queue_tail - queue_head) {
			queue_head += idx;
			uint i = queue[queue_head % QUEUE_SIZE];
			queue_head += 1;

			// should_draw[queue_head] = queue_head + 1;

			bool high_error;
			bool draw = can_draw(i, instance, high_error);

			// if (subgroupAll(draw)){
			// 	// Can just use idx instead of exclusive add for
			// simplicity
			// 	// Its pretty likely nearby clusters are drawn together
			// 	pos += idx;
			// }
			// else if (!subgroupAny(draw)){
			// 	// nothing
			// }
			// else if (draw){
			// 	pos += subgroupExclusiveAdd(1);
			// }

			if (draw) {
				pos += subgroupExclusiveAdd(1);
				should_draw[pos] = i + 1;
				pos += 1;
			}

			// pos += 1;

			bool can_queue_children = clusters[i].max_child_index >= STARTING;

			// add children to queue if we dont draw this and we have a
			// too high error

			if (i < clusters[i].co_parent && can_queue_children && !draw && high_error) {
				// debugPrintfEXT("Min child index %d\n",
				// clusters[i].min_child_index); if
				// (clusters[i].min_child_index < i){ 	while
				// (true){}
				// }

				// add to queue

				uint min_child_index = max(clusters[i].min_child_index, STARTING);

				// Allocate ourselves space at the end of the
				// queue. max_child_index >= STARTING from before

				// queue_tail +=
				// subgroupExclusiveAdd(clusters[i].max_child_index
				// - min_child_index);

				// queue_tail += idx;

				uint children = clusters[i].max_child_index - min_child_index + 1;

				queue_tail += subgroupExclusiveAdd(children);

				for (uint c = min_child_index; c <= clusters[i].max_child_index; c++) {
					// if ((queue_tail - queue_head) < QUEUE_SIZE) {
					// 	uint off = subgroupExclusiveAdd(1);
					// 	uint block = subgroupAdd(1);

					// 	queue[(queue_tail + off) % QUEUE_SIZE] = c;
					// 	queue_tail += block;
					// }

					queue[queue_tail % QUEUE_SIZE] = c;
					queue_tail += 1;
				}

				// queue[(queue_tail) % QUEUE_SIZE] =
				// clusters[i].min_child_index;
			}
		}

		pos = subgroupMax(pos);
		queue_head = subgroupMax(queue_head);
		queue_tail = subgroupMax(queue_tail);

		// if (subgroupElect()){
		// 	debugPrintfEXT("\n");
		// }
	}

	// if (subgroupElect()){ debugPrintfEXT("Finished \n"); }
	// if (subgroupElect()){ debugPrintfEXT("\n"); }

	if (subgroupElect()) {
		for (int i = 0; i < TASK_GROUP_SIZE; i++) {
			should_draw[pos + i] = 0;
		}

		indirect_draw[instance].group_size_x = ((pos + 3 - start) / TASK_GROUP_SIZE);

		ranges[instance].end = pos;
	}
}