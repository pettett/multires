#version 460

#extension GL_ARB_separate_shader_objects: enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require
#extension GL_KHR_shader_subgroup_arithmetic: enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_debug_printf : enable

#include "structs\cluster_data.glsl"
#include "structs\indirect_draw_data.glsl"
#include "structs\mesh_task_payload.glsl"
#include "structs\camera.glsl"
#include "structs\model.glsl"



//@group(0) @binding(0) var<storage, write> result_indicies: array<i32>;


// layout(binding = 0) writeonly buffer ResultIndicies {
//     uint result[];
// } result_indicies;

// layout(binding = 1) writeonly buffer DrawIndirectParams {
//     DrawIndexedIndirect result[];
// } draw_indirect_params; 



layout (binding = 0) readonly buffer ModelUniformBufferObject {
    Model models[];
};

layout(binding = 2) readonly buffer Clusters {
    ClusterData clusters[];
};

layout(binding = 1) writeonly buffer ShouldDraw {
    uint should_draw[];
};

layout (binding = 3) readonly uniform CameraUniformBufferObject {
    CameraUniformObject ubo; 
};

layout (std430, binding = 6) buffer IndirectDrawBuffer {
    IndirectDrawData indirect_draw[]; 
};

const float LARGE_ERROR = 100000000000000000.0;

float cluster_error(uint idx, uint idy) {
    bool out_of_range = false;
    if (out_of_range) {
        return LARGE_ERROR;
    } else {
		vec3 cam = (models[idy].inv_model * vec4(ubo.camera_pos, 1.0)).xyz ;
		vec3 center = clusters[idx].center;
		float radius = clusters[idx].radius;
		float error = clusters[idx].error;

		vec3 vec = center - cam;
		float inv_center_distance = 1/(dot(vec, vec));
        return error * error * radius * radius * inv_center_distance;
		
    }
}

bool can_draw(uint idx, uint idy){

	float this_error = -LARGE_ERROR;

	if (clusters[idx].co_parent >= 0) {
		this_error = min(cluster_error(idx, idy), cluster_error(clusters[idx].co_parent, idy));
	}

	// lots of zeros
	float parent_error = LARGE_ERROR;

	if (clusters[idx].parent0 >= 0) { // If we have one parent, we are guarenteed to have another.
		parent_error = min(cluster_error(clusters[idx].parent0, idy), cluster_error(clusters[idx].parent1, idy));
	}
	float error = ubo.target_error * ubo.target_error;

	bool draw = error >= this_error && error < parent_error;

	return draw;
}

const uint LOCAL_SIZE_X = 1;


layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

const int QUEUE_SIZE = 3000;
const int STARTING = 8;

shared int[QUEUE_SIZE] queue;

 
void main() {
	uint idx = gl_GlobalInvocationID.x;
    uint instance = gl_GlobalInvocationID.y;


	[[unroll]]
	for (int i = 0; i < STARTING; i++){
		queue[i] = i;
	}


	int queue_tail = STARTING;
	int queue_head = 0;

	//int old_queue_size = 0;

    //uint len = indices.result.length();

    // if (i == 0) {
    //     should_draw.result[offset + 0] = len;
    // }

    // if (i >= len) {
    //     return;
    // }
    // should_draw[i] = i32(clusters[i].index_offset);

    //uint start = clusters[i].index_offset;
    //uint end = start + clusters[i].index_count;

	// Calculate if this cluster should be drawn:
	// draw_error >= min(self.error, self.co-parent.error) 
	// draw_error < min(parent0.error, parent1.error)

	uint pos = 0;

	//for (uint i = id.x; i < clusters.length(); i += LOCAL_SIZE_X){
		// lots of negative zeros

	// only evaluate if we are within the bounds of the queue

	while (queue_tail - queue_head > 0){

		//old_queue_size = queue_tail - queue_head;

		memoryBarrierShared();

		if (idx < queue_tail - queue_head){

		queue_head += subgroupExclusiveAdd(1);
		int i = queue[queue_head % QUEUE_SIZE];

		//should_draw[queue_head] = queue_head + 1;


		bool draw = can_draw(i, instance);
		
		if (draw){
			pos += subgroupExclusiveAdd(1);
			should_draw[pos] = i + 1;
			pos += 1;
		}
		queue_head += 1;

		// pos += 1;

		bool can_queue_children = clusters[i].max_child_index >= STARTING ;

		
		// add children to queue if we dont draw this

		if (i < clusters[i].co_parent && can_queue_children && !draw){

			// debugPrintfEXT("Min child index %d\n", clusters[i].min_child_index);
			// if (clusters[i].min_child_index < i){
			// 	while (true){}
			// }

			// add to queue

			int min_child_index = max(clusters[i].min_child_index, STARTING);

			//Allocate ourselves space at the end of the queue. max_child_index >= STARTING from before
			queue_tail += subgroupExclusiveAdd(clusters[i].max_child_index - min_child_index);


			for (int c = min_child_index ; c <= clusters[i].max_child_index  ; c++){
	
				if ((queue_tail - queue_head) < QUEUE_SIZE) {
					
					queue[queue_tail % QUEUE_SIZE] = c;
					queue_tail += 1;

				}
			}
				
			//queue[(queue_tail) % QUEUE_SIZE] = clusters[i].min_child_index;
			

		}
		}

		pos = subgroupMax(pos);
		queue_head = subgroupMax(queue_head);
		queue_tail = subgroupMax(queue_tail);
	}


	if (subgroupElect()) {

		for (int i = 0; i < TASK_GROUP_SIZE; i++){
			should_draw[pos + i] = 0;
		}

		indirect_draw[instance].group_size_x = ((pos + 3) / TASK_GROUP_SIZE);
	}
}