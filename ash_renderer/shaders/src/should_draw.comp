#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters : require
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "structs\camera.glsl"
#include "structs\cluster_data.glsl"
#include "structs\model.glsl"

//@group(0) @binding(0) var<storage, write> result_indicies: array<i32>;

// layout(binding = 0) writeonly buffer ResultIndicies {
//     uint result[];
// } result_indicies;

// layout(binding = 1) writeonly buffer DrawIndirectParams {
//     DrawIndexedIndirect result[];
// } draw_indirect_params;

layout(binding = 0) readonly buffer ModelUniformBufferObject {
	Model models[];
};

layout(binding = 2) readonly buffer Clusters {
	ClusterData clusters[];
};

layout(binding = 1) writeonly buffer ShouldDraw {
	uint should_draw[];
};

layout(binding = 3) readonly uniform CameraUniformBufferObject {
	CameraUniformObject ubo;
};


#include "util\culling.glsl"
#include "util\cluster.glsl"

const uint LOCAL_SIZE_X = 1;

layout(local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

void main() {
	uvec3 id = gl_GlobalInvocationID;
	uint cluster_index = id.x;
	uint instance_index = id.y;


	vec3 local_cam_pos;
	bool high_error;
	bool draw = cluster_can_draw(cluster_index, instance_index, local_cam_pos, high_error);

	mat4 MVP = ubo.culling_view_proj * models[instance_index].model;
	// Generate object space clipping planes

	vec4 planes[6] = planes_from_mat(MVP);

	bool in_clip = sphere_inside_planes(planes, clusters[cluster_index].tight_sphere);


	should_draw[cluster_index] = draw && in_clip  ? cluster_index + 1 : 0;
}