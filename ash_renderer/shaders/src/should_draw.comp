#version 460

#extension GL_ARB_separate_shader_objects: enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require

#extension GL_KHR_shader_subgroup_arithmetic: enable

#include "structs\cluster_data.glsl"
#include "structs\camera.glsl"



//@group(0) @binding(0) var<storage, write> result_indicies: array<i32>;


// layout(binding = 0) writeonly buffer ResultIndicies {
//     uint result[];
// } result_indicies;

// layout(binding = 1) writeonly buffer DrawIndirectParams {
//     DrawIndexedIndirect result[];
// } draw_indirect_params; 


layout (binding = 0) readonly buffer ModelUniformBufferObject {
    mat4 models[];
};

layout(binding = 1) readonly buffer Clusters {
    ClusterData clusters[];
};

layout(binding = 2) writeonly buffer ShouldDraw {
    uint should_draw[];
};

layout (binding = 3) readonly uniform CameraUniformBufferObject {
    CameraUniformObject ubo; 
};

const float LARGE_ERROR = 100000000000000000.0;

float cluster_error(uint idx, uint i) {
    bool out_of_range = false;
    if (out_of_range) {
        return LARGE_ERROR;
    } else {
        return clusters[idx].error * (clusters[idx].radius / distance((models[i] * vec4(clusters[idx].center, 1.0)).xyz, ubo.camera_pos));
    }
}

const uint LOCAL_SIZE_X = 1;

layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;
 
void main() {
	uvec3 id = gl_GlobalInvocationID;
    uint i = id.x;
    uint instance = id.y;
    //uint len = indices.result.length();

    // if (i == 0) {
    //     should_draw.result[offset + 0] = len;
    // }

    // if (i >= len) {
    //     return;
    // }
    // should_draw[i] = i32(clusters[i].index_offset);

    //uint start = clusters[i].index_offset;
    //uint end = start + clusters[i].index_count;

	// Calculate if this cluster should be drawn:
	// draw_error >= min(self.error, self.co-parent.error) 
	// draw_error < min(parent0.error, parent1.error)

	// lots of negative zeros
    float this_error = -LARGE_ERROR;

    if (clusters[i].co_parent >= 0) {
        this_error = min(cluster_error(i, instance), cluster_error(clusters[i].co_parent, instance));
    }

	// lots of zeros
    float parent_error = LARGE_ERROR;

    if (clusters[i].parent0 >= 0) { // If we have one parent, we are guarenteed to have another.
        parent_error = min(cluster_error(clusters[i].parent0, instance), cluster_error(clusters[i].parent1, instance));
    }

    bool cull = ubo.target_error >= this_error && ubo.target_error < parent_error;

    should_draw[i] = cull ? i + 1 : 0;
	
}