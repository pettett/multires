#version 450
#extension GL_EXT_mesh_shader: require

#extension GL_ARB_separate_shader_objects: enable

#extension GL_KHR_shader_subgroup_arithmetic: enable

#include "shaders/src/mesh_task_payload.glsl"


const float LARGE_ERROR = 100000000000000000.0;

// Bindings and layout

layout (local_size_x = TASK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer ModelUniformBufferObject {
    mat4 models[];
} model;

layout (binding = 5) uniform CameraUniformBufferObject {
    mat4 view_proj;
	vec3 camera_pos;
	float target_error;
} ubo;

struct ClusterData {
    // Range into the index array that this submesh resides
    vec3 center;

    uint _index_offset;
    uint _index_count;

	float error;
    //radius: f32,
    // All of these could be none (-1), if we are a leaf or a root node
    int parent0;
    int parent1;

    int co_parent;
	// Filler draw_data for alignment
    float radius;
    uint layer;
    int max_child_index;

	int _3;
    int _4;
    uint meshlet_start;
	uint meshlet_count;
};

layout (std430, binding = 2) readonly buffer InputBufferC {
    ClusterData clusters[];
} cluster_data;


// Workgroup Shared memory
//shared uint max_count;
taskPayloadSharedEXT MeshTaskPayload payload;


float cluster_error(uint idx, uint idy) {
    //bool out_of_range = idx >= draw_data.current_count;
    //if out_of_range {
    //    return LARGE_ERROR;
    //} else {

		float center_distance = distance((model.models[idy] * vec4(cluster_data.clusters[idx].center, 1.0)).xyz, ubo.camera_pos);
        return cluster_data.clusters[idx].error * (cluster_data.clusters[idx].radius / center_distance);
		//return cluster_data.clusters[idx].error;
	//}
}


void main() {
    uint cluster_index = gl_GlobalInvocationID.x;
    uint local_index = gl_LocalInvocationID.x;
    uint instance_index = gl_GlobalInvocationID.y;
	


    if (cluster_index >= cluster_data.clusters.length()) {
    	payload.meshlet_start[local_index] = -1;
    	payload.meshlet_count[local_index] = -1;
        return;
    }


	// Calculate if this cluster should be drawn:
	// draw_error >= min(self.error, self.co-parent.error) 
	// draw_error < min(parent0.error, parent1.error)

	// lots of negative zeros
    float this_error = -LARGE_ERROR;

    if (cluster_data.clusters[cluster_index].co_parent >= 0) {
        this_error = min(
			cluster_error(cluster_index, instance_index), 
			cluster_error(uint(cluster_data.clusters[cluster_index].co_parent), instance_index)
			);
    }

	// lots of zeros
    float parent_error = LARGE_ERROR;

    if (cluster_data.clusters[cluster_index].parent0 >= 0) { // If we have one parent, we are guarenteed to have another.
        parent_error = min(
			cluster_error(uint(cluster_data.clusters[cluster_index].parent0), instance_index), 
			cluster_error(uint(cluster_data.clusters[cluster_index].parent1), instance_index)
			);
    }

	float error =  ubo.target_error;

    bool draw = error >= this_error && error < parent_error;

    payload.meshlet_start[local_index] = draw ? cluster_data.clusters[cluster_index].meshlet_start : -1;
    payload.meshlet_count[local_index] = draw ? cluster_data.clusters[cluster_index].meshlet_count : 0;
    payload.instance = instance_index;
	
	//max_count = 0;

	//barrier();

	//if (local_index % 2 == 0){
	//	atomicMax(max_count, max(payload.meshlet_count[local_index], payload.meshlet_count[local_index+1]) );
	//}

	uint max_count = subgroupMax(payload.meshlet_count[local_index]);

    EmitMeshTasksEXT(max_count, TASK_GROUP_SIZE, 1);
	

} 