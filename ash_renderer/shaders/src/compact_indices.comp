#version 460

#extension GL_ARB_separate_shader_objects: enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require

#extension GL_KHR_shader_subgroup_arithmetic: enable

#include "structs\cluster_data.glsl"

layout(binding = 1) readonly buffer Clusters {
    ClusterData clusters[];
};

layout(binding = 2) readonly buffer ShouldDraw {
    uint should_draw[];
};

layout(binding = 5) writeonly buffer ResultIndicies {
    uint result_indicies[];
};

layout(binding = 6) readonly buffer Indicies {
    uint indices[];
};


const uint LOCAL_SIZE_X = 16;

layout (local_size_x = LOCAL_SIZE_X, local_size_y = 1, local_size_z = 1) in;

void main(  ) {
	uvec3 id = gl_GlobalInvocationID;
	uint lid = gl_LocalInvocationID.x;
	uint gid = gl_WorkGroupID.x;

    uint idx = id.x;
    uint len = indices.length();
	
	// For the end workgroup
    // if (idx >= should_draw[offset]) {
    //     return;
    // }
 

	// Initialise scan to list of sizes [2,0,0,3,1,0,0]

	// Add workgroups before this workgroup
	uint thread_sum = 0;

    for (uint group = 0; group < gid; group++) {
		uint meshlet = group * LOCAL_SIZE_X + lid;
		if (should_draw[meshlet] > 0){
    	    thread_sum += clusters[meshlet].index_count;
		}
    }

    uint group_base = subgroupAdd(thread_sum);
	
	// Add things within this workgroup
	bool cull = should_draw[idx] > 0;

	uint idx_val = group_base + subgroupExclusiveAdd(cull ? clusters[idx].index_count : 0);


	// Scan should now look like [2,2,2,5,6,6,6]

	// Undo the starting addition to get our pack positions

	// Scan should now look like [0,-,-,2,5,-,-]
    if (cull) {

        //var result_start: u32 = 0u;

        uint ind_start = clusters[idx].index_offset;

		
		// Ideally, compute this in a step after writing cull to a buffer and compacting it down
        for (uint ind = 0; ind < clusters[idx].index_count; ind++) {
            result_indicies[idx_val + ind] = indices[ind_start + ind];
        }

    }

	// Fill the max index count from the final work item

    // if (idx == should_draw[offset + 0] - 1) {
    //     draw_indirect_params[id.y].index_count = idx_val;
    // }
}