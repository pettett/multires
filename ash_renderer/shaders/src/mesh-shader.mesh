#version 450

#extension GL_EXT_mesh_shader: require

#extension GL_ARB_separate_shader_objects: enable

#include "shaders/src/mesh_task_payload.glsl"


const uint MAX_PRIMITIVES = 126;
const uint MAX_VERTS = 64;


struct Vertex {
    vec4 pos;
    vec4 normal;
};


// https://github.com/KhronosGroup/Vulkan-Samples/blob/26eb94f79f9c2377cbaa28db2fbd7dd6efb55ffe/framework/api_vulkan_sample.h#L89
struct s_meshlet
{
    uint vertices[MAX_VERTS]; // 64
    uint indices[MAX_PRIMITIVES * 3]; // 126 triangles => 378 indices
    uint vertex_count;
    uint index_count;
};

layout (binding = 0) readonly buffer ModelUniformBufferObject {
    mat4 models[];
} model;

layout (binding = 5) uniform CameraUniformBufferObject {
    mat4 view_proj;
	vec3 camera_pos;
	float target_error;
} ubo;

layout (std430, binding = 3) readonly buffer InputBufferI {
    s_meshlet meshlets[];
} indices;

// std430 is **really** important
layout (std430, binding = 4) readonly buffer InputBufferV {
    Vertex verts[];
} sourceData;




layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = MAX_VERTS, max_primitives = MAX_PRIMITIVES) out;

layout (location = 0) out Interpolants {
    vec3 fragColor;
    vec2 fragTexCoord;
} OUT[];


taskPayloadSharedEXT MeshTaskPayload payload;

vec3 integer_to_rgb(float integer) {
    float red = mod((integer * 109.0 + 47.0), 269.0) / 269.0;
    float green = mod((integer * 83.0 + 251.0), 127.0) / 127.0;
    float blue = mod((integer * 251.0 + 83.0), 293.0) / 293.0;
    return vec3(red, green, blue);
}

void vert(uint v, uint meshlet_index) {
    // gl_MeshVerticesEXT[v].gl_Position = ubo.view_proj * ubo.model * p;
    uint vert_idx = indices.meshlets[meshlet_index].vertices[v];
    gl_MeshVerticesEXT[v].gl_Position = ubo.view_proj * model.models[payload.instance] * vec4(sourceData.verts[vert_idx].pos.xyz, 1);
    OUT[v].fragColor = integer_to_rgb(meshlet_index);
    OUT[v].fragTexCoord = vec2(1, 1);
}

void main() {
    uint thread_id = gl_GlobalInvocationID.x;
    uint cluster_id = gl_GlobalInvocationID.y;

	if (thread_id >= payload.meshlet_count[cluster_id]){
    	SetMeshOutputsEXT(0, 0);
		return;
	}

    uint meshlet_index = payload.meshlet_start[cluster_id] + thread_id;

    s_meshlet meshlet = indices.meshlets[meshlet_index];

	const uint vertex_count = min(MAX_VERTS, meshlet.vertex_count);
	const uint primitive_count = min(MAX_PRIMITIVES, meshlet.index_count / 3);

    SetMeshOutputsEXT(vertex_count, primitive_count);

    // pub const RECT_TEX_COORD_INDICES_DATA: [u32; 12] = [0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4];
    for (uint i = 0; i < vertex_count; i++) {
        vert(i, meshlet_index);
    }

    for (uint i = 0; i < primitive_count; i++) {
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(meshlet.indices[i * 3], meshlet.indices[i * 3 + 1], meshlet.indices[i * 3 + 2]);
    }
}