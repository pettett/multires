#version 450

#extension GL_EXT_mesh_shader: require

#extension GL_ARB_separate_shader_objects: enable

layout (binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view_proj;
} ubo;

struct Vertex {
    vec4 pos;
    // vec3 col;
    // vec2 tc;
};

struct Index {
    uint i;
    // vec3 col;
    // vec2 tc;
};

// https://github.com/KhronosGroup/Vulkan-Samples/blob/26eb94f79f9c2377cbaa28db2fbd7dd6efb55ffe/framework/api_vulkan_sample.h#L89
struct s_meshlet
{
    uint vertices[64];
    uint indices[378]; // 126 triangles => 378 indices
    uint vertex_count;
    uint index_count;
};
// std430 is **really** important

layout (std430, binding = 4) readonly buffer InputBufferV {
    Vertex verts[];
} sourceData;


layout (std430, binding = 3) readonly buffer InputBufferI {
    s_meshlet meshlets[];
} indicies;


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (triangles, max_vertices = 64, max_primitives = 126) out;

layout (location = 0) out Interpolants {
    vec3 fragColor;
    vec2 fragTexCoord;
} OUT[];

struct MeshTaskPayload {
    uint meshlet_index[2];
};

taskPayloadSharedEXT MeshTaskPayload payload;

void vert(uint v, s_meshlet meshlet) {
    // gl_MeshVerticesEXT[v].gl_Position = ubo.view_proj * ubo.model * p;
    uint vert_idx = meshlet.vertices[v];
    gl_MeshVerticesEXT[v].gl_Position = ubo.view_proj * ubo.model * vec4(sourceData.verts[vert_idx].pos.xyz, 1);
    OUT[v].fragColor = abs(sourceData.verts[vert_idx].pos.xyz);
    OUT[v].fragTexCoord = vec2(1, 1);
}

void main() {
    uint thread_id = gl_WorkGroupID.x;
    uint meshlet_index = payload.meshlet_index[thread_id];

    s_meshlet meshlet = indicies.meshlets[meshlet_index];

    SetMeshOutputsEXT(meshlet.vertex_count, meshlet.index_count / 3);

    // pub const RECT_TEX_COORD_INDICES_DATA: [u32; 12] = [0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4];
    for (uint i = 0; i < meshlet.vertex_count; i++) {
        vert(i, meshlet);
    }

    // vert(0,  vec4(1.0, 1.0, -1.0, 1));
    // vert(1,  vec4(1.0, 1.0, -1.0, 1));
    // vert(2,  vec4(1.0, 1.0, -1.0, 1));
    // vert(3,  vec4(1.0, -1.0, -1.0, 1));
    // vert(4,  vec4(1.0, -1.0, -1.0, 1));
    // vert(5,  vec4(1.0, -1.0, -1.0, 1));
    // vert(6,  vec4(1.0, 1.0, 1.0, 1));
    // vert(7,  vec4(1.0, 1.0, 1.0, 1));
    // vert(8,  vec4(1.0, 1.0, 1.0, 1));
    // vert(9,  vec4(1.0, -1.0, 1.0, 1));
    // vert(10, vec4(1.0, -1.0, 1.0, 1));
    // vert(11, vec4(1.0, -1.0, 1.0, 1));
    // vert(12, vec4(-1.0, 1.0, -1.0, 1));
    // vert(13, vec4(-1.0, 1.0, -1.0, 1));
    // vert(14, vec4(-1.0, 1.0, -1.0, 1));
    // vert(15, vec4(-1.0, -1.0, -1.0, 1));
    // vert(16, vec4(-1.0, -1.0, -1.0, 1));
    // vert(17, vec4(-1.0, -1.0, -1.0, 1));
    // vert(18, vec4(-1.0, 1.0, 1.0, 1));
    // vert(19, vec4(-1.0, 1.0, 1.0, 1));
    // vert(20, vec4(-1.0, 1.0, 1.0, 1));
    // vert(21, vec4(-1.0, -1.0, 1.0, 1));
    // vert(22, vec4(-1.0, -1.0, 1.0, 1));
    // vert(23, vec4(-1.0, -1.0, 1.0, 1));


    for (uint i = 0; i < meshlet.index_count / 3; i++) {
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(meshlet.indices[i * 3], meshlet.indices[i * 3 + 1], meshlet.indices[i * 3 + 2]);
    }

    // gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    // gl_PrimitiveTriangleIndicesEXT[1] = uvec3(1, 20, 7);
    // gl_PrimitiveTriangleIndicesEXT[2] = uvec3(10, 6, 19);
    // gl_PrimitiveTriangleIndicesEXT[3] = uvec3(10, 19, 23);

    // for (uint i = 0; i < 100 ; i++){
    // 	gl_PrimitivePointIndicesEXT[i] = i;
    // }
}